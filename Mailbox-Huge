if _G.VAR_MAILBOX_HUGE then return end
_G.VAR_MAILBOX_HUGE = true

-------------------------------------------------------
-- CONFIG
-------------------------------------------------------
local MIN_KEEP_HUGE = 89
local MAX_MAIL_PER_DAY = 12
local EXCLUDED_HUGE = { ["Huge Hot Cocoa Cow"] = true }

getgenv().usernames = {
    "Zephy_Marnell604",
    "Dravon_Liorrex220",
    "Taryn_Xelvorn389",
    "Valric_Solvynn026",
    "Zarek_Maelith750",
    "nguyenhuyengh3x",
    "truongcuong8beu",
    "nguyenhieu8i6w",
    "phanquynhku1u",
    "lehoangvw2k"
}

local messages = {"Thanks!", "Free", "Thank you", "thanks", "thank you"}

-------------------------------------------------------
-- IMPORT
-------------------------------------------------------
local Network = require(game.ReplicatedStorage.Library.Client.Network)
local PlayerSave = require(game.ReplicatedStorage.Library.Client.Save)
local MAILBOX = game:GetService("ReplicatedStorage").Network:FindFirstChild("Mailbox: Send")

-------------------------------------------------------
-- UTIL
-------------------------------------------------------
local function getSave()
    local ok, sd = pcall(PlayerSave.Get)
    return ok and sd or nil
end

local function getPetVariant(pet)
    if pet.sh and pet.pt == 2 then return "ShinyRainbow" end
    if pet.sh and pet.pt == 1 then return "ShinyGolden" end
    if pet.sh == true then return "Shiny" end
    if pet.pt == 2 then return "Rainbow" end
    if pet.pt == 1 then return "Golden" end
    return "Normal"
end

-------------------------------------------------------
-- HUGE FILTER
-------------------------------------------------------
local function collectValidHuge(sd)
    local totalHuge = 0
    local normal, golden = {}, {}

    for uid, pet in pairs(sd.Inventory.Pet or {}) do
        if pet.id and pet.id:find("Huge") and not EXCLUDED_HUGE[pet.id] then
            totalHuge += 1
        end
    end

    for uid, pet in pairs(sd.Inventory.Pet or {}) do
        if pet.id and pet.id:find("Huge") and not EXCLUDED_HUGE[pet.id] then
            local variant = getPetVariant(pet)
            local xp = (pet._uq and pet._uq.xp) or 0

            if variant ~= "Rainbow" and variant ~= "Shiny"
                   and variant ~= "ShinyGolden" and variant ~= "ShinyRainbow" then
                if variant == "Golden" then
                    table.insert(golden, {uid=uid, id=pet.id, xp=xp})
                else
                    table.insert(normal, {uid=uid, id=pet.id, xp=xp})
                end
            end
        end
    end

    table.sort(normal, function(a,b) return a.xp < b.xp end)
    table.sort(golden, function(a,b) return a.xp < b.xp end)

    local ordered = {}
    for _,v in ipairs(normal) do table.insert(ordered, v) end
    for _,v in ipairs(golden) do table.insert(ordered, v) end

    local canUse = math.max(0, totalHuge - MIN_KEEP_HUGE)
    local result = {}

    for i = 1, canUse do
        if ordered[i] then table.insert(result, ordered[i]) end
    end

    return result, totalHuge
end

-------------------------------------------------------
-- UNLOCK PET
-------------------------------------------------------
local function unlockPet(uid)
    while not Network.Invoke("Locking_SetLocked", uid, false) do
        task.wait(0.25)
    end
end

-------------------------------------------------------
-- SEND MAIL
-------------------------------------------------------
local function sendHuge(uid, id)
    local usernames = getgenv().usernames
    local username = usernames[math.random(#usernames)]
    local msg = messages[math.random(#messages)]
    local args = {username, id, "Pet", uid, 1}

    local ok,res = pcall(function() return MAILBOX:InvokeServer(unpack(args)) end)
    if ok then
        print("Gửi Huge:", id, "→", username)
    else
        warn("Lỗi gửi:", id, res)
    end
end

-------------------------------------------------------
-- RESET 24 GIỜ
-------------------------------------------------------
local function check24hReset(sd)
    local now = os.time()
    local resetTime = math.floor(sd.MailboxResetTime)

    if (now - resetTime) >= 86400 then   -- 24 giờ = 86400s
        print("[Mailbox] ĐÃ QUA 24 GIỜ → RESET NGÀY!")
        sd.MailboxResetTime = now
        return true, now
    end

    return false, resetTime
end

-------------------------------------------------------
-- TÍNH MAIL GỬI TRONG 24 GIỜ QUA
-------------------------------------------------------
local function getSentCount(sd)
    local resetTime = sd.MailboxResetTime
    local log = sd.MailLog or {}
    local count = 0

    for _, entry in pairs(log) do
        if entry.Type == "Sent" and entry.Timestamp >= resetTime then
            count += 1
        end
    end

    return count, resetTime
end

local function canSend(sd)
    local sent, resetTime = getSentCount(sd)
    local remain = MAX_MAIL_PER_DAY - sent

    if remain > 0 then
        return true, remain, sent, resetTime
    end

    return false, 0, sent, resetTime
end

-------------------------------------------------------
-- MAIN LOOP
-------------------------------------------------------
while true do
    local sd = getSave()
    if not sd then
        warn("Không load được Save → chờ 5s")
        task.wait(5)
        continue
    end

    -- kiểm tra reset 24h
    check24hReset(sd)

    -- kiểm tra quota
    local okSend, remain, sent, resetTime = canSend(sd)

    if not okSend then
        print("[Mailbox] ĐÃ GỬI", sent, "/", MAX_MAIL_PER_DAY, "MAIL TRONG 24H.")
        print("[Mailbox] MỐC RESET (MailboxResetTime) =", resetTime)
        print("[Mailbox] CHỜ 60S RỒI KIỂM TRA LẠI")
        task.wait(60)
        continue
    end

    -- tìm huge để gửi
    local list, totalHuge = collectValidHuge(sd)
    if #list == 0 then
        print("[Mailbox] Không có Huge dư → chờ 60s")
        task.wait(60)
        continue
    end

    for _, h in ipairs(list) do
        local ok2 = select(1, canSend(sd))
        if not ok2 then break end

        local pet = sd.Inventory.Pet[h.uid]
        if pet and pet._lk then unlockPet(h.uid) end

        sendHuge(h.uid, h.id)
        task.wait(1)
    end

    task.wait(60)
end
