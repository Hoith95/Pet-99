-- ===== CONFIG =====
local PRIORITIZE_EXCLUDE = true        -- true = hop ngay khi thấy excluded (bất kể số người) [chỉ kiểm tra 1 lần lúc start]
local CASE_INSENSITIVE = false         -- true nếu muốn so sánh không phân biệt hoa/thường
local MAX_PLAYERS_BELOW = 10           -- nếu không có excluded lúc start, hop khi số người <= giá trị này
local SERVERHOP_COOLDOWN = 300         -- cooldown giữa 2 lần hop (giây)
local CHECK_INTERVAL = 5               -- khoảng kiểm tra vòng lặp chính (giây)
local DIAMOND_KEY = "\240\159\146\142 Diamonds" -- key leaderstats kim cương

local DEBUG_LOG = false                -- bật để in debug (đặt true khi cần)
-- Danh sách username cần tránh (mặc định case-sensitive; bật CASE_INSENSITIVE để ignore case)
local usernamesToExclude = {
    ["Zephy_Marnell604"] = true,
    ["Dravon_Liorrex220"] = true,
    ["Taryn_Xelvorn389"] = true,
    ["Valric_Solvynn026"] = true,
    ["Zarek_Maelith750"] = true,
    ["nguyenhuyengh3x"] = true,
    ["truongcuong8beu"] = true,
    ["nguyenhieu8i6w"] = true,
    ["phanquynhku1u"] = true,
    ["lehoangvw2k"] = true,
}
-- ====================

-- wait until game + leaderstats ready
repeat task.wait() until game:IsLoaded()
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local leaderstats = localPlayer:WaitForChild("leaderstats")

-- normalize exclude table if needed
local excludeNormalized = {}
if CASE_INSENSITIVE then
    for k, v in pairs(usernamesToExclude) do
        excludeNormalized[string.lower(k)] = v
    end
end

local function isExcludedUsername(name)
    if not name then return false end
    if CASE_INSENSITIVE then
        return excludeNormalized[string.lower(name)]
    else
        return usernamesToExclude[name]
    end
end

-- safe initial diamonds
local initialDiamonds = 0
if leaderstats:FindFirstChild(DIAMOND_KEY) then
    initialDiamonds = leaderstats[DIAMOND_KEY].Value
else
    warn("Không tìm thấy key kim cương: " .. tostring(DIAMOND_KEY) .. ". initialDiamonds = 0")
end

-- hop control
local isHopping = false
local lastHopTime = 0

local function canHop()
    if isHopping then return false end
    local now = os.time()
    if (now - lastHopTime) < SERVERHOP_COOLDOWN then
        return false
    end
    return true
end

local function serverHop()
    if not canHop() then
        if DEBUG_LOG then print("[ServerHop] Không thể hop (đang hop hoặc cooldown).") end
        return false
    end

    -- set flags EARLY để tránh các lần gọi đồng thời / race
    isHopping = true
    lastHopTime = os.time()   -- gán ngay trước khi gọi script bên ngoài

    print("[ServerHop] Bắt đầu ServerHop... (lastHopTime set)")

    local ok, err = pcall(function()
        -- main hop script (giữ nguyên links)
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Hoith95/Pet-99/main/ServerHop-Plaza"))()
        task.wait(60)
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Hoith95/Pet-99/main/JoinLow"))()
    end)

    isHopping = false

    if not ok then
        warn("[ServerHop] Lỗi khi chạy: " .. tostring(err))
        return false
    end

    print("[ServerHop] Hoàn tất.")
    return true
end

local function hasExcludedPlayer()
    for _, p in ipairs(Players:GetPlayers()) do
        if isExcludedUsername(p.Name) then
            return true, p.Name
        end
    end
    return false, nil
end

-- === CHECK EXCLUDED ONCE AT START ===
local initialExcluded, initialWho = hasExcludedPlayer()
if initialExcluded then
    print("[Start] Phát hiện excluded user lúc khởi chạy: " .. tostring(initialWho) .. " -> hop ngay.")
    serverHop()
    -- sau khi hop script thường disconnect; vẫn return để dừng phần còn lại
    return
else
    if DEBUG_LOG then print("[Start] Không phát hiện excluded lúc khởi chạy. Tiếp tục với main loop.") end
end
-- =====================================

-- Main loop: KHÔNG kiểm tra excluded nữa, chỉ kiểm playerCount theo cấu hình
task.spawn(function()
    while true do
        task.wait(CHECK_INTERVAL)

        if isHopping then
            -- đang hop, skip vòng này
            if DEBUG_LOG then print("[Main] Đang hop, skip vòng check.") end
        else
            local playerCount = #Players:GetPlayers()

            if DEBUG_LOG then
                print(string.format("[Main][DEBUG] playerCount=%d", playerCount))
            end

            -- Nếu PRIORITIZE_EXCLUDE = true thì đã xử lý lúc start (không check lại)
            -- Chúng ta chỉ cần check số người: hop khi playerCount <= MAX_PLAYERS_BELOW
            if playerCount <= MAX_PLAYERS_BELOW then
                print("[Main] Số người <= " .. MAX_PLAYERS_BELOW .. " -> hop theo quy tắc.")
                serverHop()
                return -- kết thúc thread (thường bị disconnect sau hop)
            else
                if DEBUG_LOG then print("[Main] Server có " .. playerCount .. " người (> " .. MAX_PLAYERS_BELOW .. "). Chờ.") end
                -- tiếp tục vòng lặp
            end
        end
    end
end)

-- Check diamonds sau 1 giờ (chạy 1 lần)
task.spawn(function()
    print("[Diamonds] Initial: " .. tostring(initialDiamonds))
    task.wait(3600) -- 1 giờ
    local cur = 0
    if leaderstats:FindFirstChild(DIAMOND_KEY) then
        cur = leaderstats[DIAMOND_KEY].Value
    else
        warn("[Diamonds] Không tìm thấy key khi check sau 1 giờ.")
    end

    if cur == initialDiamonds then
        print("[Diamonds] Không tăng sau 1 giờ -> thực hiện ServerHop.")
        serverHop()
    else
        print("[Diamonds] Đã thay đổi: " .. tostring(initialDiamonds) .. " -> " .. tostring(cur) .. " -> không hop.")
    end
end)

-- Claim Mailbox mỗi 3 phút
task.spawn(function()
    while true do
        task.wait(180)
        local ok, res = pcall(function()
            local net = game:GetService("ReplicatedStorage"):WaitForChild("Network")
            local mailbox = net:WaitForChild("Mailbox: Claim All")
            mailbox:InvokeServer()
        end)
        if ok then
            print("[Mailbox] Đã nhận toàn bộ thư.")
        else
            warn("[Mailbox] Lỗi khi claim: " .. tostring(res))
        end
    end
end)
